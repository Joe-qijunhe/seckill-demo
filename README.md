# 秒杀系统

基于 SpringBoot + Redis + RabbitMQ 实现的一个秒杀系统

## 简介

秒杀系统主要应用在商品抢购的场景，比如：电商抢购限量商品、卖周董演唱会的门票、火车票抢座等

秒杀系统抽象来说就是以下几个步骤：

- 用户选定商品下单
- 校验库存
- 扣库存
- 创建用户订单
- 用户支付等后续步骤

如果项目流量非常小，完全不用担心有并发的购买请求，但如果系统要像12306那样，接受高并发访问和下单的考验，那么你就需要一套完整的**流程保护措施**，来保证你系统在用户流量高峰期不会被搞挂了。这些措施有什么呢：

- **严格防止超卖**：库存100件你卖了120件，等着辞职吧
- **防止黑产**：防止不怀好意的人群通过各种技术手段把你本该下发给群众的利益全收入了囊中。
- **保证用户体验**：高并发下，别网页打不开了，支付不成功了，购物车进不去了，地址改不了了。这个问题非常之大，涉及到各种技术，也不是一下子就能讲完的，甚至根本就没法讲完。

总的来说，秒杀系统需要具备以下特点：

- **高性能**：秒杀涉及大量的并发读和并发写，因此支持高并发访问这点非常关键。对应的方案比如动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务端的极致优化
- **一致性**：秒杀中商品减库存的实现方式同样关键。可想而知，有限数量的商品在同一时刻被很多倍的请求同时来减库存，减库存又分为“拍下减库存”“付款减库存”以及预扣等几种，在大并发更新的过程中都要保证数据的准确性，其难度可想而知
- **高可用**：现实中总难免出现一些我们考虑不到的情况，所以要保证系统的高可用和正确性，我们还要设计一个 PlanB 来兜底，以便在最坏情况发生时仍然能够从容应对

## 核心技术

- 引入 Redis 作为缓存层，缓存更新频率低但访问量极高的数据，如商品列表。同时，利用其单线程特性，结合Lua脚本的原子性操作，在Redis层面实现预减库存等操作，有效规避了超卖风险，并确保了一人一单。
- 集成了 RabbitMQ 来实现了秒杀订单的异步化处理。当秒杀成功时，订单信息被推送至消息队列，由专门的订单服务异步消费并执行后续的库存扣减、订单生成等复杂操作。这一设计不仅有效缓解了秒杀高峰时段的数据库压力，还实现了流量的平滑处理，即“削峰填谷”，确保系统在高并发环境下依然能够稳定运行。


<img src=".\README.assets\秒杀流程.drawio.png" alt="秒杀流程" />
